/* tslint:disable */
/* eslint-disable */
/**
 * Prime Studio API
 * API specifications for Prime Studio
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration'
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
	DUMMY_BASE_URL,
	assertParamExists,
	setSearchParams,
	serializeDataIfNeeded,
	toPathString,
	createRequestFunction,
} from './common'
// @ts-ignore
import { BASE_PATH, RequestArgs, BaseAPI } from './base'

/**
 * Banner response body
 * @export
 * @interface Banner
 */
export interface Banner {
	/**
	 *
	 * @type {number}
	 * @memberof Banner
	 */
	id: number
	/**
	 *
	 * @type {string}
	 * @memberof Banner
	 */
	indexKey: string
	/**
	 *
	 * @type {string}
	 * @memberof Banner
	 */
	PK: string
	/**
	 *
	 * @type {string}
	 * @memberof Banner
	 */
	SK: string
	/**
	 *
	 * @type {string}
	 * @memberof Banner
	 */
	createdAt: string
	/**
	 *
	 * @type {string}
	 * @memberof Banner
	 */
	createdUser: string
	/**
	 *
	 * @type {string}
	 * @memberof Banner
	 */
	updatedAt: string
	/**
	 *
	 * @type {string}
	 * @memberof Banner
	 */
	updatedUser: string
	/**
	 *
	 * @type {boolean}
	 * @memberof Banner
	 */
	invalid: boolean
	/**
	 *
	 * @type {string}
	 * @memberof Banner
	 */
	note?: string
	/**
	 *
	 * @type {string}
	 * @memberof Banner
	 */
	name: string
	/**
	 *
	 * @type {string}
	 * @memberof Banner
	 */
	description: string
	/**
	 *
	 * @type {string}
	 * @memberof Banner
	 */
	image?: string
	/**
	 *
	 * @type {string}
	 * @memberof Banner
	 */
	link?: string
}
/**
 * Banner image response body
 * @export
 * @interface BannerImage
 */
export interface BannerImage {
	/**
	 *
	 * @type {string}
	 * @memberof BannerImage
	 */
	url: string
}
/**
 * Category response body
 * @export
 * @interface Category
 */
export interface Category {
	/**
	 *
	 * @type {number}
	 * @memberof Category
	 */
	id: number
	/**
	 *
	 * @type {string}
	 * @memberof Category
	 */
	indexKey: string
	/**
	 *
	 * @type {string}
	 * @memberof Category
	 */
	PK: string
	/**
	 *
	 * @type {string}
	 * @memberof Category
	 */
	SK: string
	/**
	 *
	 * @type {string}
	 * @memberof Category
	 */
	createdAt: string
	/**
	 *
	 * @type {string}
	 * @memberof Category
	 */
	createdUser: string
	/**
	 *
	 * @type {string}
	 * @memberof Category
	 */
	updatedAt: string
	/**
	 *
	 * @type {string}
	 * @memberof Category
	 */
	updatedUser: string
	/**
	 *
	 * @type {boolean}
	 * @memberof Category
	 */
	invalid: boolean
	/**
	 *
	 * @type {string}
	 * @memberof Category
	 */
	note?: string
	/**
	 *
	 * @type {string}
	 * @memberof Category
	 */
	name: string
	/**
	 *
	 * @type {string}
	 * @memberof Category
	 */
	description?: string
	/**
	 *
	 * @type {string}
	 * @memberof Category
	 */
	parentId: string
	/**
	 *
	 * @type {string}
	 * @memberof Category
	 */
	parent?: string
}
/**
 * Favorite from dynamoDB
 * @export
 * @interface Favorite
 */
export interface Favorite {
	/**
	 *
	 * @type {string}
	 * @memberof Favorite
	 */
	indexKey: string
	/**
	 *
	 * @type {string}
	 * @memberof Favorite
	 */
	PK: string
	/**
	 *
	 * @type {string}
	 * @memberof Favorite
	 */
	SK: string
	/**
	 *
	 * @type {string}
	 * @memberof Favorite
	 */
	createdAt: string
}
/**
 *
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
	/**
	 *
	 * @type {Array<ValidationError>}
	 * @memberof HTTPValidationError
	 */
	detail?: Array<ValidationError>
}
/**
 * Like for video
 * @export
 * @interface Like
 */
export interface Like {
	/**
	 *
	 * @type {string}
	 * @memberof Like
	 */
	indexKey: string
	/**
	 *
	 * @type {string}
	 * @memberof Like
	 */
	PK: string
	/**
	 *
	 * @type {string}
	 * @memberof Like
	 */
	SK: string
	/**
	 *
	 * @type {string}
	 * @memberof Like
	 */
	createdAt: string
	/**
	 *
	 * @type {string}
	 * @memberof Like
	 */
	createdUser: string
	/**
	 *
	 * @type {boolean}
	 * @memberof Like
	 */
	like: boolean
}
/**
 * Likes for video
 * @export
 * @interface Likes
 */
export interface Likes {
	/**
	 *
	 * @type {Array<Like>}
	 * @memberof Likes
	 */
	good: Array<Like>
	/**
	 *
	 * @type {Array<Like>}
	 * @memberof Likes
	 */
	bad: Array<Like>
}
/**
 * Learning Path response body
 * @export
 * @interface Path
 */
export interface Path {
	/**
	 *
	 * @type {number}
	 * @memberof Path
	 */
	id: number
	/**
	 *
	 * @type {string}
	 * @memberof Path
	 */
	indexKey: string
	/**
	 *
	 * @type {string}
	 * @memberof Path
	 */
	PK: string
	/**
	 *
	 * @type {string}
	 * @memberof Path
	 */
	SK: string
	/**
	 *
	 * @type {string}
	 * @memberof Path
	 */
	createdAt: string
	/**
	 *
	 * @type {string}
	 * @memberof Path
	 */
	createdUser: string
	/**
	 *
	 * @type {string}
	 * @memberof Path
	 */
	updatedAt: string
	/**
	 *
	 * @type {string}
	 * @memberof Path
	 */
	updatedUser: string
	/**
	 *
	 * @type {boolean}
	 * @memberof Path
	 */
	invalid: boolean
	/**
	 *
	 * @type {string}
	 * @memberof Path
	 */
	note?: string
	/**
	 *
	 * @type {string}
	 * @memberof Path
	 */
	name: string
	/**
	 *
	 * @type {string}
	 * @memberof Path
	 */
	description: string
	/**
	 *
	 * @type {Array<VideoOrder>}
	 * @memberof Path
	 */
	videos?: Array<VideoOrder>
}
/**
 * Privacy from Vimeo
 * @export
 * @interface PrivacyVimeo
 */
export interface PrivacyVimeo {
	/**
	 *
	 * @type {string}
	 * @memberof PrivacyVimeo
	 */
	view: string
}
/**
 * Post banner request body
 * @export
 * @interface ReqBannerPost
 */
export interface ReqBannerPost {
	/**
	 *
	 * @type {string}
	 * @memberof ReqBannerPost
	 */
	user: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqBannerPost
	 */
	name: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqBannerPost
	 */
	description: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqBannerPost
	 */
	image: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqBannerPost
	 */
	link?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqBannerPost
	 */
	note?: string
}
/**
 * Put banner request body
 * @export
 * @interface ReqBannerPut
 */
export interface ReqBannerPut {
	/**
	 *
	 * @type {string}
	 * @memberof ReqBannerPut
	 */
	PK: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqBannerPut
	 */
	user: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqBannerPut
	 */
	name?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqBannerPut
	 */
	description?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqBannerPut
	 */
	image?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqBannerPut
	 */
	link?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqBannerPut
	 */
	note?: string
	/**
	 *
	 * @type {boolean}
	 * @memberof ReqBannerPut
	 */
	invalid?: boolean
}
/**
 * Post category request body
 * @export
 * @interface ReqCategoryPost
 */
export interface ReqCategoryPost {
	/**
	 *
	 * @type {string}
	 * @memberof ReqCategoryPost
	 */
	user: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqCategoryPost
	 */
	name: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqCategoryPost
	 */
	description: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqCategoryPost
	 */
	note?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqCategoryPost
	 */
	parentId?: string
}
/**
 * Put category request body
 * @export
 * @interface ReqCategoryPut
 */
export interface ReqCategoryPut {
	/**
	 *
	 * @type {string}
	 * @memberof ReqCategoryPut
	 */
	PK: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqCategoryPut
	 */
	user: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqCategoryPut
	 */
	name?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqCategoryPut
	 */
	parentId?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqCategoryPut
	 */
	description?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqCategoryPut
	 */
	note?: string
	/**
	 *
	 * @type {boolean}
	 * @memberof ReqCategoryPut
	 */
	invalid?: boolean
}
/**
 * Favorite request body
 * @export
 * @interface ReqFavorite
 */
export interface ReqFavorite {
	/**
	 *
	 * @type {string}
	 * @memberof ReqFavorite
	 */
	user: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqFavorite
	 */
	video: string
}
/**
 * File request body
 * @export
 * @interface ReqFile
 */
export interface ReqFile {
	/**
	 *
	 * @type {string}
	 * @memberof ReqFile
	 */
	name: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqFile
	 */
	description: string
	/**
	 *
	 * @type {number}
	 * @memberof ReqFile
	 */
	size: number
}
/**
 * History request body
 * @export
 * @interface ReqHistory
 */
export interface ReqHistory {
	/**
	 *
	 * @type {string}
	 * @memberof ReqHistory
	 */
	user: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqHistory
	 */
	video: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqHistory
	 */
	createdAt: string
	/**
	 *
	 * @type {number}
	 * @memberof ReqHistory
	 */
	parse?: number
	/**
	 *
	 * @type {string}
	 * @memberof ReqHistory
	 */
	finishedAt?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqHistory
	 */
	referrer?: string
}
/**
 * Delete like request body
 * @export
 * @interface ReqLikeDelete
 */
export interface ReqLikeDelete {
	/**
	 *
	 * @type {string}
	 * @memberof ReqLikeDelete
	 */
	video: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqLikeDelete
	 */
	id: string
}
/**
 * Post like request body
 * @export
 * @interface ReqLikePost
 */
export interface ReqLikePost {
	/**
	 *
	 * @type {string}
	 * @memberof ReqLikePost
	 */
	video: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqLikePost
	 */
	user: string
	/**
	 *
	 * @type {boolean}
	 * @memberof ReqLikePost
	 */
	like: boolean
}
/**
 *
 * @export
 * @interface ReqPathDeleteTransact
 */
export interface ReqPathDeleteTransact {
	/**
	 *
	 * @type {string}
	 * @memberof ReqPathDeleteTransact
	 */
	PK: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqPathDeleteTransact
	 */
	user: string
}
/**
 * Post learning path request body
 * @export
 * @interface ReqPathPost
 */
export interface ReqPathPost {
	/**
	 *
	 * @type {string}
	 * @memberof ReqPathPost
	 */
	name: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqPathPost
	 */
	description: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqPathPost
	 */
	note?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqPathPost
	 */
	user: string
}
/**
 * Put learningh path request body
 * @export
 * @interface ReqPathPutTransact
 */
export interface ReqPathPutTransact {
	/**
	 *
	 * @type {string}
	 * @memberof ReqPathPutTransact
	 */
	PK: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqPathPutTransact
	 */
	user: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqPathPutTransact
	 */
	name?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqPathPutTransact
	 */
	description?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqPathPutTransact
	 */
	note?: string
	/**
	 *
	 * @type {boolean}
	 * @memberof ReqPathPutTransact
	 */
	invalid?: boolean
	/**
	 *
	 * @type {Array<string>}
	 * @memberof ReqPathPutTransact
	 */
	appended?: Array<string>
	/**
	 *
	 * @type {Array<string>}
	 * @memberof ReqPathPutTransact
	 */
	removed?: Array<string>
	/**
	 *
	 * @type {Array<VideoOrder>}
	 * @memberof ReqPathPutTransact
	 */
	orders?: Array<VideoOrder>
}
/**
 * Delete tag request body
 * @export
 * @interface ReqTagDelete
 */
export interface ReqTagDelete {
	/**
	 *
	 * @type {string}
	 * @memberof ReqTagDelete
	 */
	PK: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqTagDelete
	 */
	user: string
}
/**
 * Post tag request body
 * @export
 * @interface ReqTagPost
 */
export interface ReqTagPost {
	/**
	 *
	 * @type {string}
	 * @memberof ReqTagPost
	 */
	user: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqTagPost
	 */
	name: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqTagPost
	 */
	description?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqTagPost
	 */
	note?: string
}
/**
 * Put tag request body
 * @export
 * @interface ReqTagPut
 */
export interface ReqTagPut {
	/**
	 *
	 * @type {string}
	 * @memberof ReqTagPut
	 */
	PK: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqTagPut
	 */
	user: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqTagPut
	 */
	name?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqTagPut
	 */
	description?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqTagPut
	 */
	note?: string
	/**
	 *
	 * @type {boolean}
	 * @memberof ReqTagPut
	 */
	invalid?: boolean
}
/**
 * Delete thread request body
 * @export
 * @interface ReqThreadDelete
 */
export interface ReqThreadDelete {
	/**
	 *
	 * @type {string}
	 * @memberof ReqThreadDelete
	 */
	video: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqThreadDelete
	 */
	id: string
}
/**
 * Post thread request body
 * @export
 * @interface ReqThreadPost
 */
export interface ReqThreadPost {
	/**
	 *
	 * @type {string}
	 * @memberof ReqThreadPost
	 */
	video: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqThreadPost
	 */
	user: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqThreadPost
	 */
	body: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqThreadPost
	 */
	thread?: string
}
/**
 * Put thread request body
 * @export
 * @interface ReqThreadPut
 */
export interface ReqThreadPut {
	/**
	 *
	 * @type {string}
	 * @memberof ReqThreadPut
	 */
	video: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqThreadPut
	 */
	id: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqThreadPut
	 */
	body?: string
	/**
	 *
	 * @type {boolean}
	 * @memberof ReqThreadPut
	 */
	invalid?: boolean
}
/**
 * Post upload status request body
 * @export
 * @interface ReqUploadStatusPost
 */
export interface ReqUploadStatusPost {
	/**
	 *
	 * @type {string}
	 * @memberof ReqUploadStatusPost
	 */
	uri: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqUploadStatusPost
	 */
	user: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqUploadStatusPost
	 */
	name: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqUploadStatusPost
	 */
	filename: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqUploadStatusPost
	 */
	status: string
}
/**
 * Put upload status request body
 * @export
 * @interface ReqUploadStatusPut
 */
export interface ReqUploadStatusPut {
	/**
	 *
	 * @type {string}
	 * @memberof ReqUploadStatusPut
	 */
	uri: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqUploadStatusPut
	 */
	timestamp: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqUploadStatusPut
	 */
	status: string
}
/**
 * Post & Put user request body
 * @export
 * @interface ReqUser
 */
export interface ReqUser {
	/**
	 *
	 * @type {string}
	 * @memberof ReqUser
	 */
	PK: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqUser
	 */
	name?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqUser
	 */
	image?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqUser
	 */
	acl?: string
}
/**
 * Post video request body
 * @export
 * @interface ReqVideoPost
 */
export interface ReqVideoPost {
	/**
	 *
	 * @type {string}
	 * @memberof ReqVideoPost
	 */
	PK: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqVideoPost
	 */
	user: string
	/**
	 *
	 * @type {boolean}
	 * @memberof ReqVideoPost
	 */
	invalid?: boolean
	/**
	 *
	 * @type {string}
	 * @memberof ReqVideoPost
	 */
	note?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqVideoPost
	 */
	description: string
	/**
	 *
	 * @type {Array<string>}
	 * @memberof ReqVideoPost
	 */
	learningPathIds?: Array<string>
	/**
	 *
	 * @type {Array<string>}
	 * @memberof ReqVideoPost
	 */
	tagIds?: Array<string>
	/**
	 *
	 * @type {string}
	 * @memberof ReqVideoPost
	 */
	categoryId: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqVideoPost
	 */
	uri?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqVideoPost
	 */
	thumbnail?: string
	/**
	 *
	 * @type {number}
	 * @memberof ReqVideoPost
	 */
	plays?: number
	/**
	 *
	 * @type {string}
	 * @memberof ReqVideoPost
	 */
	name?: string
	/**
	 *
	 * @type {number}
	 * @memberof ReqVideoPost
	 */
	duration?: number
	/**
	 *
	 * @type {string}
	 * @memberof ReqVideoPost
	 */
	html?: string
}
/**
 * Put video request body
 * @export
 * @interface ReqVideoPut
 */
export interface ReqVideoPut {
	/**
	 *
	 * @type {string}
	 * @memberof ReqVideoPut
	 */
	PK: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqVideoPut
	 */
	user: string
	/**
	 *
	 * @type {boolean}
	 * @memberof ReqVideoPut
	 */
	invalid?: boolean
	/**
	 *
	 * @type {string}
	 * @memberof ReqVideoPut
	 */
	note?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqVideoPut
	 */
	description?: string
	/**
	 *
	 * @type {Array<string>}
	 * @memberof ReqVideoPut
	 */
	learningPathIds?: Array<string>
	/**
	 *
	 * @type {Array<string>}
	 * @memberof ReqVideoPut
	 */
	tagIds?: Array<string>
	/**
	 *
	 * @type {string}
	 * @memberof ReqVideoPut
	 */
	categoryId?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqVideoPut
	 */
	uri?: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqVideoPut
	 */
	thumbnail?: string
	/**
	 *
	 * @type {number}
	 * @memberof ReqVideoPut
	 */
	plays?: number
	/**
	 *
	 * @type {string}
	 * @memberof ReqVideoPut
	 */
	name?: string
	/**
	 *
	 * @type {number}
	 * @memberof ReqVideoPut
	 */
	duration?: number
	/**
	 *
	 * @type {string}
	 * @memberof ReqVideoPut
	 */
	html?: string
}
/**
 * Pt vimeo request body
 * @export
 * @interface ReqVimeoPut
 */
export interface ReqVimeoPut {
	/**
	 *
	 * @type {string}
	 * @memberof ReqVimeoPut
	 */
	PK: string
	/**
	 *
	 * @type {string}
	 * @memberof ReqVimeoPut
	 */
	name: string
}
/**
 * Response upload status
 * @export
 * @interface ResUploadStatus
 */
export interface ResUploadStatus {
	/**
	 *
	 * @type {string}
	 * @memberof ResUploadStatus
	 */
	uri: string
	/**
	 *
	 * @type {string}
	 * @memberof ResUploadStatus
	 */
	timestamp: string
	/**
	 *
	 * @type {string}
	 * @memberof ResUploadStatus
	 */
	status: string
}
/**
 * Stats from Vimeo
 * @export
 * @interface StatsVimeo
 */
export interface StatsVimeo {
	/**
	 *
	 * @type {number}
	 * @memberof StatsVimeo
	 */
	plays: number
}
/**
 * Tag response body
 * @export
 * @interface Tag
 */
export interface Tag {
	/**
	 *
	 * @type {string}
	 * @memberof Tag
	 */
	id: string
	/**
	 *
	 * @type {string}
	 * @memberof Tag
	 */
	indexKey: string
	/**
	 *
	 * @type {string}
	 * @memberof Tag
	 */
	PK: string
	/**
	 *
	 * @type {string}
	 * @memberof Tag
	 */
	SK: string
	/**
	 *
	 * @type {string}
	 * @memberof Tag
	 */
	createdAt: string
	/**
	 *
	 * @type {string}
	 * @memberof Tag
	 */
	createdUser: string
	/**
	 *
	 * @type {string}
	 * @memberof Tag
	 */
	updatedAt: string
	/**
	 *
	 * @type {string}
	 * @memberof Tag
	 */
	updatedUser: string
	/**
	 *
	 * @type {boolean}
	 * @memberof Tag
	 */
	invalid: boolean
	/**
	 *
	 * @type {string}
	 * @memberof Tag
	 */
	note?: string
	/**
	 *
	 * @type {string}
	 * @memberof Tag
	 */
	name: string
	/**
	 *
	 * @type {string}
	 * @memberof Tag
	 */
	description: string
}
/**
 * Thread for video
 * @export
 * @interface Thread
 */
export interface Thread {
	/**
	 *
	 * @type {string}
	 * @memberof Thread
	 */
	indexKey: string
	/**
	 *
	 * @type {string}
	 * @memberof Thread
	 */
	PK: string
	/**
	 *
	 * @type {string}
	 * @memberof Thread
	 */
	SK: string
	/**
	 *
	 * @type {string}
	 * @memberof Thread
	 */
	createdAt: string
	/**
	 *
	 * @type {string}
	 * @memberof Thread
	 */
	createdUser: string
	/**
	 *
	 * @type {string}
	 * @memberof Thread
	 */
	body: string
}
/**
 * Thumbnail from Vimeo
 * @export
 * @interface ThumbnailVimeo
 */
export interface ThumbnailVimeo {
	/**
	 *
	 * @type {number}
	 * @memberof ThumbnailVimeo
	 */
	width: number
	/**
	 *
	 * @type {number}
	 * @memberof ThumbnailVimeo
	 */
	height: number
	/**
	 *
	 * @type {string}
	 * @memberof ThumbnailVimeo
	 */
	link: string
	/**
	 *
	 * @type {string}
	 * @memberof ThumbnailVimeo
	 */
	link_with_play_button?: string
}
/**
 * File for vimeo upload
 * @export
 * @interface UploadFile
 */
export interface UploadFile {
	/**
	 *
	 * @type {string}
	 * @memberof UploadFile
	 */
	uri: string
	/**
	 *
	 * @type {string}
	 * @memberof UploadFile
	 */
	name: string
	/**
	 *
	 * @type {string}
	 * @memberof UploadFile
	 */
	type: string
	/**
	 *
	 * @type {string}
	 * @memberof UploadFile
	 */
	description: string
	/**
	 *
	 * @type {string}
	 * @memberof UploadFile
	 */
	link: string
	/**
	 *
	 * @type {string}
	 * @memberof UploadFile
	 */
	upload_link: string
}
/**
 * Upload status
 * @export
 * @interface UploadStatus
 */
export interface UploadStatus {
	/**
	 *
	 * @type {string}
	 * @memberof UploadStatus
	 */
	PK: string
	/**
	 *
	 * @type {string}
	 * @memberof UploadStatus
	 */
	SK: string
	/**
	 *
	 * @type {string}
	 * @memberof UploadStatus
	 */
	id: string
	/**
	 *
	 * @type {string}
	 * @memberof UploadStatus
	 */
	indexKey: string
	/**
	 *
	 * @type {string}
	 * @memberof UploadStatus
	 */
	createdAt: string
	/**
	 *
	 * @type {string}
	 * @memberof UploadStatus
	 */
	createdUser: string
	/**
	 *
	 * @type {string}
	 * @memberof UploadStatus
	 */
	name: string
	/**
	 *
	 * @type {string}
	 * @memberof UploadStatus
	 */
	filename: string
	/**
	 *
	 * @type {string}
	 * @memberof UploadStatus
	 */
	status: string
}
/**
 * User response body
 * @export
 * @interface User
 */
export interface User {
	/**
	 *
	 * @type {number}
	 * @memberof User
	 */
	id: number
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	indexKey: string
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	PK: string
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	SK: string
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	createdAt: string
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	updatedAt: string
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	name: string
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	image?: string
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	acl?: string
}
/**
 * History from dynamoDB
 * @export
 * @interface UserHistory
 */
export interface UserHistory {
	/**
	 *
	 * @type {string}
	 * @memberof UserHistory
	 */
	indexKey: string
	/**
	 *
	 * @type {string}
	 * @memberof UserHistory
	 */
	PK: string
	/**
	 *
	 * @type {string}
	 * @memberof UserHistory
	 */
	SK: string
	/**
	 *
	 * @type {string}
	 * @memberof UserHistory
	 */
	createdAt: string
	/**
	 *
	 * @type {string}
	 * @memberof UserHistory
	 */
	videoUri: string
	/**
	 *
	 * @type {number}
	 * @memberof UserHistory
	 */
	parse?: number
	/**
	 *
	 * @type {string}
	 * @memberof UserHistory
	 */
	finishedAt?: string
	/**
	 *
	 * @type {string}
	 * @memberof UserHistory
	 */
	referrer?: string
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
	/**
	 *
	 * @type {Array<string>}
	 * @memberof ValidationError
	 */
	loc: Array<string>
	/**
	 *
	 * @type {string}
	 * @memberof ValidationError
	 */
	msg: string
	/**
	 *
	 * @type {string}
	 * @memberof ValidationError
	 */
	type: string
}
/**
 * Video response body
 * @export
 * @interface Video
 */
export interface Video {
	/**
	 *
	 * @type {string}
	 * @memberof Video
	 */
	indexKey?: string
	/**
	 *
	 * @type {string}
	 * @memberof Video
	 */
	PK?: string
	/**
	 *
	 * @type {string}
	 * @memberof Video
	 */
	SK?: string
	/**
	 *
	 * @type {string}
	 * @memberof Video
	 */
	createdAt?: string
	/**
	 *
	 * @type {string}
	 * @memberof Video
	 */
	createdUser?: string
	/**
	 *
	 * @type {string}
	 * @memberof Video
	 */
	updatedAt?: string
	/**
	 *
	 * @type {string}
	 * @memberof Video
	 */
	updatedUser?: string
	/**
	 *
	 * @type {boolean}
	 * @memberof Video
	 */
	invalid?: boolean
	/**
	 *
	 * @type {string}
	 * @memberof Video
	 */
	note?: string
	/**
	 *
	 * @type {string}
	 * @memberof Video
	 */
	description?: string
	/**
	 *
	 * @type {Array<string>}
	 * @memberof Video
	 */
	learningPathIds?: Array<string>
	/**
	 *
	 * @type {Array<string>}
	 * @memberof Video
	 */
	tagIds?: Array<string>
	/**
	 *
	 * @type {string}
	 * @memberof Video
	 */
	categoryId?: string
	/**
	 *
	 * @type {boolean}
	 * @memberof Video
	 */
	match?: boolean
	/**
	 *
	 * @type {string}
	 * @memberof Video
	 */
	uri?: string
	/**
	 *
	 * @type {ThumbnailVimeo}
	 * @memberof Video
	 */
	thumbnail?: ThumbnailVimeo
	/**
	 *
	 * @type {number}
	 * @memberof Video
	 */
	plays?: number
	/**
	 *
	 * @type {string}
	 * @memberof Video
	 */
	name?: string
	/**
	 *
	 * @type {number}
	 * @memberof Video
	 */
	duration?: number
	/**
	 *
	 * @type {string}
	 * @memberof Video
	 */
	html?: string
	/**
	 *
	 * @type {StatsVimeo}
	 * @memberof Video
	 */
	stats?: StatsVimeo
	/**
	 *
	 * @type {PrivacyVimeo}
	 * @memberof Video
	 */
	privacy?: PrivacyVimeo
}
/**
 * Video from DynamoDB
 * @export
 * @interface VideoDB
 */
export interface VideoDB {
	/**
	 *
	 * @type {string}
	 * @memberof VideoDB
	 */
	indexKey?: string
	/**
	 *
	 * @type {string}
	 * @memberof VideoDB
	 */
	PK?: string
	/**
	 *
	 * @type {string}
	 * @memberof VideoDB
	 */
	SK?: string
	/**
	 *
	 * @type {string}
	 * @memberof VideoDB
	 */
	createdAt?: string
	/**
	 *
	 * @type {string}
	 * @memberof VideoDB
	 */
	createdUser?: string
	/**
	 *
	 * @type {string}
	 * @memberof VideoDB
	 */
	updatedAt?: string
	/**
	 *
	 * @type {string}
	 * @memberof VideoDB
	 */
	updatedUser?: string
	/**
	 *
	 * @type {boolean}
	 * @memberof VideoDB
	 */
	invalid?: boolean
	/**
	 *
	 * @type {string}
	 * @memberof VideoDB
	 */
	note?: string
	/**
	 *
	 * @type {string}
	 * @memberof VideoDB
	 */
	description?: string
	/**
	 *
	 * @type {Array<string>}
	 * @memberof VideoDB
	 */
	learningPathIds?: Array<string>
	/**
	 *
	 * @type {Array<string>}
	 * @memberof VideoDB
	 */
	tagIds?: Array<string>
	/**
	 *
	 * @type {string}
	 * @memberof VideoDB
	 */
	categoryId?: string
	/**
	 *
	 * @type {boolean}
	 * @memberof VideoDB
	 */
	match?: boolean
	/**
	 *
	 * @type {string}
	 * @memberof VideoDB
	 */
	uri?: string
	/**
	 *
	 * @type {string}
	 * @memberof VideoDB
	 */
	thumbnail?: string
	/**
	 *
	 * @type {number}
	 * @memberof VideoDB
	 */
	plays?: number
	/**
	 *
	 * @type {string}
	 * @memberof VideoDB
	 */
	name?: string
	/**
	 *
	 * @type {number}
	 * @memberof VideoDB
	 */
	duration?: number
	/**
	 *
	 * @type {string}
	 * @memberof VideoDB
	 */
	html?: string
}
/**
 * Video search request body
 * @export
 * @interface VideoFilter
 */
export interface VideoFilter {
	/**
	 *
	 * @type {string}
	 * @memberof VideoFilter
	 */
	categoryId?: string
	/**
	 *
	 * @type {string}
	 * @memberof VideoFilter
	 */
	tagId?: string
	/**
	 *
	 * @type {string}
	 * @memberof VideoFilter
	 */
	learningPathId?: string
	/**
	 *
	 * @type {string}
	 * @memberof VideoFilter
	 */
	name?: string
}
/**
 * Video order contain learning path
 * @export
 * @interface VideoOrder
 */
export interface VideoOrder {
	/**
	 *
	 * @type {string}
	 * @memberof VideoOrder
	 */
	uri: string
	/**
	 *
	 * @type {number}
	 * @memberof VideoOrder
	 */
	order?: number
}
/**
 * Video table row
 * @export
 * @interface VideoTableRow
 */
export interface VideoTableRow {
	/**
	 *
	 * @type {number}
	 * @memberof VideoTableRow
	 */
	id: number
	/**
	 *
	 * @type {boolean}
	 * @memberof VideoTableRow
	 */
	match: boolean
	/**
	 *
	 * @type {string}
	 * @memberof VideoTableRow
	 */
	uri?: string
	/**
	 *
	 * @type {boolean}
	 * @memberof VideoTableRow
	 */
	invalid?: boolean
	/**
	 *
	 * @type {string}
	 * @memberof VideoTableRow
	 */
	thumbnail?: string
	/**
	 *
	 * @type {string}
	 * @memberof VideoTableRow
	 */
	name?: string
	/**
	 *
	 * @type {string}
	 * @memberof VideoTableRow
	 */
	description?: string
	/**
	 *
	 * @type {string}
	 * @memberof VideoTableRow
	 */
	primary?: string
	/**
	 *
	 * @type {string}
	 * @memberof VideoTableRow
	 */
	secondary?: string
	/**
	 *
	 * @type {Array<string>}
	 * @memberof VideoTableRow
	 */
	tags?: Array<string>
	/**
	 *
	 * @type {Array<string>}
	 * @memberof VideoTableRow
	 */
	paths?: Array<string>
	/**
	 *
	 * @type {string}
	 * @memberof VideoTableRow
	 */
	note?: string
	/**
	 *
	 * @type {number}
	 * @memberof VideoTableRow
	 */
	duration?: number
	/**
	 *
	 * @type {number}
	 * @memberof VideoTableRow
	 */
	plays?: number
	/**
	 *
	 * @type {string}
	 * @memberof VideoTableRow
	 */
	createdAt?: string
	/**
	 *
	 * @type {string}
	 * @memberof VideoTableRow
	 */
	createdUser?: string
	/**
	 *
	 * @type {string}
	 * @memberof VideoTableRow
	 */
	updatedAt?: string
	/**
	 *
	 * @type {string}
	 * @memberof VideoTableRow
	 */
	updatedUser?: string
}
/**
 *
 * @export
 * @interface VideoVimeo
 */
export interface VideoVimeo {
	/**
	 *
	 * @type {string}
	 * @memberof VideoVimeo
	 */
	uri?: string
	/**
	 *
	 * @type {string}
	 * @memberof VideoVimeo
	 */
	name?: string
	/**
	 *
	 * @type {number}
	 * @memberof VideoVimeo
	 */
	duration?: number
	/**
	 *
	 * @type {number}
	 * @memberof VideoVimeo
	 */
	plays?: number
	/**
	 *
	 * @type {string}
	 * @memberof VideoVimeo
	 */
	privacy?: string
	/**
	 *
	 * @type {string}
	 * @memberof VideoVimeo
	 */
	html?: string
	/**
	 *
	 * @type {string}
	 * @memberof VideoVimeo
	 */
	thumbnail?: string
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 * delete category meta
		 * @summary Delete Category
		 * @param {any} categoryId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteCategoryCategoryCategoryIdDelete: async (
			categoryId: any,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'categoryId' is not null or undefined
			assertParamExists(
				'deleteCategoryCategoryCategoryIdDelete',
				'categoryId',
				categoryId
			)
			const localVarPath = `/category/{category_id}`.replace(
				`{${'category_id'}}`,
				encodeURIComponent(String(categoryId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'DELETE',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Delete favorite video from DynamoDB
		 * @summary Delete Favorite
		 * @param {ReqFavorite} reqFavorite
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteFavoriteFavoriteDelete: async (
			reqFavorite: ReqFavorite,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqFavorite' is not null or undefined
			assertParamExists(
				'deleteFavoriteFavoriteDelete',
				'reqFavorite',
				reqFavorite
			)
			const localVarPath = `/favorite`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'DELETE',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqFavorite,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Delete like for video from DynamoDB
		 * @summary Delete Like
		 * @param {ReqLikeDelete} reqLikeDelete
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteLikeLikeDelete: async (
			reqLikeDelete: ReqLikeDelete,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqLikeDelete' is not null or undefined
			assertParamExists(
				'deleteLikeLikeDelete',
				'reqLikeDelete',
				reqLikeDelete
			)
			const localVarPath = `/like`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'DELETE',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqLikeDelete,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Delete learning path and relations from DynamoDB
		 * @summary Delete Path
		 * @param {ReqPathDeleteTransact} reqPathDeleteTransact
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deletePathPathDelete: async (
			reqPathDeleteTransact: ReqPathDeleteTransact,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqPathDeleteTransact' is not null or undefined
			assertParamExists(
				'deletePathPathDelete',
				'reqPathDeleteTransact',
				reqPathDeleteTransact
			)
			const localVarPath = `/path`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'DELETE',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqPathDeleteTransact,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * delete tag meta and video/tag relations
		 * @summary Delete Tag
		 * @param {ReqTagDelete} reqTagDelete
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteTagTagDelete: async (
			reqTagDelete: ReqTagDelete,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqTagDelete' is not null or undefined
			assertParamExists(
				'deleteTagTagDelete',
				'reqTagDelete',
				reqTagDelete
			)
			const localVarPath = `/tag`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'DELETE',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqTagDelete,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Delete thread for video from DynamoDB
		 * @summary Delete Thread
		 * @param {ReqThreadDelete} reqThreadDelete
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteThreadThreadDelete: async (
			reqThreadDelete: ReqThreadDelete,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqThreadDelete' is not null or undefined
			assertParamExists(
				'deleteThreadThreadDelete',
				'reqThreadDelete',
				reqThreadDelete
			)
			const localVarPath = `/thread`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'DELETE',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqThreadDelete,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get videos from vimeo by multi process
		 * @summary Get Async Vimeo Videos Multi Process
		 * @param {boolean} [all]
		 * @param {number} [page]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getAsyncVimeoVideosMultiProcessVimeoVideosAsyncGet: async (
			all?: boolean,
			page?: number,
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/vimeo/videos/async`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			if (all !== undefined) {
				localVarQueryParameter['all'] = all
			}

			if (page !== undefined) {
				localVarQueryParameter['page'] = page
			}

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get banners from DynamoDB
		 * @summary Get Banners
		 * @param {boolean} [active]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getBannersBannersGet: async (
			active?: boolean,
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/banners`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			if (active !== undefined) {
				localVarQueryParameter['active'] = active
			}

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get categories from dynamoDB
		 * @summary Get Categories
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getCategoriesCategoriesGet: async (
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/categories`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get videos from DynamoDB
		 * @summary Get Db Videos
		 * @param {boolean} [all]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getDbVideosDbVideosGet: async (
			all?: boolean,
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/db/videos`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			if (all !== undefined) {
				localVarQueryParameter['all'] = all
			}

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get videos from DynamoDB
		 * @summary Get Db Videos Filtered
		 * @param {VideoFilter} videoFilter
		 * @param {boolean} [all]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getDbVideosFilteredDbVideosPost: async (
			videoFilter: VideoFilter,
			all?: boolean,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'videoFilter' is not null or undefined
			assertParamExists(
				'getDbVideosFilteredDbVideosPost',
				'videoFilter',
				videoFilter
			)
			const localVarPath = `/db/videos`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			if (all !== undefined) {
				localVarQueryParameter['all'] = all
			}

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				videoFilter,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get favorite videos for each user from DynamoDB
		 * @summary Get Favorite
		 * @param {any} userId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getFavoriteFavoriteUserIdGet: async (
			userId: any,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'userId' is not null or undefined
			assertParamExists('getFavoriteFavoriteUserIdGet', 'userId', userId)
			const localVarPath = `/favorite/{user_id}`.replace(
				`{${'user_id'}}`,
				encodeURIComponent(String(userId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get histories today
		 * @summary Get Histories
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getHistoriesHistoriesGet: async (
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/histories`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get histories for each user from DynamoDB
		 * @summary Get History
		 * @param {any} userId
		 * @param {number} [limit]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getHistoryHistoryUserIdGet: async (
			userId: any,
			limit?: number,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'userId' is not null or undefined
			assertParamExists('getHistoryHistoryUserIdGet', 'userId', userId)
			const localVarPath = `/history/{user_id}`.replace(
				`{${'user_id'}}`,
				encodeURIComponent(String(userId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			if (limit !== undefined) {
				localVarQueryParameter['limit'] = limit
			}

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get like for video from DynamoDB
		 * @summary Get Likes
		 * @param {any} videoId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLikesLikeVideoIdGet: async (
			videoId: any,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'videoId' is not null or undefined
			assertParamExists('getLikesLikeVideoIdGet', 'videoId', videoId)
			const localVarPath = `/like/{video_id}`.replace(
				`{${'video_id'}}`,
				encodeURIComponent(String(videoId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get learning path from DynamoDB
		 * @summary Get Path
		 * @param {any} pathId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getPathPathPathIdGet: async (
			pathId: any,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'pathId' is not null or undefined
			assertParamExists('getPathPathPathIdGet', 'pathId', pathId)
			const localVarPath = `/path/{path_id}`.replace(
				`{${'path_id'}}`,
				encodeURIComponent(String(pathId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Get Paths Db
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getPathsDbPathsPathsGet: async (
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/paths/paths`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get learning paths and video orders from DynamoDB
		 * @summary Get Paths
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getPathsPathsGet: async (options: any = {}): Promise<RequestArgs> => {
			const localVarPath = `/paths`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get videos & playback orders included in learning paths
		 * @summary Get Paths Videos
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getPathsVideosPathsVideosGet: async (
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/paths/videos`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get videos merged VimeoAPI & DynamoDB for table
		 * @summary Get Table Videos
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getTableVideosTableVideosGet: async (
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/table/videos`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get tags from dynamoDB
		 * @summary Get Tags
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getTagsTagsGet: async (options: any = {}): Promise<RequestArgs> => {
			const localVarPath = `/tags`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get threads for video from DynamoDB
		 * @summary Get Thread
		 * @param {any} videoId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getThreadThreadVideoIdGet: async (
			videoId: any,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'videoId' is not null or undefined
			assertParamExists('getThreadThreadVideoIdGet', 'videoId', videoId)
			const localVarPath = `/thread/{video_id}`.replace(
				`{${'video_id'}}`,
				encodeURIComponent(String(videoId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get upload status to vimeo
		 * @summary Get Transcode Status
		 * @param {string} videoId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getTranscodeStatusVideoStatusGet: async (
			videoId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'videoId' is not null or undefined
			assertParamExists(
				'getTranscodeStatusVideoStatusGet',
				'videoId',
				videoId
			)
			const localVarPath = `/video/status/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			if (videoId !== undefined) {
				localVarQueryParameter['video_id'] = videoId
			}

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get upload status from DynamoDB
		 * @summary Get Upload Status
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getUploadStatusUploadStatusGet: async (
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/upload/status`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get login users today
		 * @summary Get User Count
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getUserCountUsersLoginGet: async (
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/users/login`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get user from DynamoDB
		 * @summary Get User
		 * @param {any} userId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getUserUserUserIdGet: async (
			userId: any,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'userId' is not null or undefined
			assertParamExists('getUserUserUserIdGet', 'userId', userId)
			const localVarPath = `/user/{user_id}`.replace(
				`{${'user_id'}}`,
				encodeURIComponent(String(userId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get users from dynamoDB
		 * @summary Get Users
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getUsersUsersGet: async (options: any = {}): Promise<RequestArgs> => {
			const localVarPath = `/users`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get video from DynamoDB
		 * @summary Get Video
		 * @param {any} videoId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getVideoVideoVideoIdGet: async (
			videoId: any,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'videoId' is not null or undefined
			assertParamExists('getVideoVideoVideoIdGet', 'videoId', videoId)
			const localVarPath = `/video/{video_id}`.replace(
				`{${'video_id'}}`,
				encodeURIComponent(String(videoId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * get videos contain any tag
		 * @summary Get Videos Contain Any Category
		 * @param {any} categoryId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getVideosContainAnyCategoryVideosCategoryIdGet: async (
			categoryId: any,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'categoryId' is not null or undefined
			assertParamExists(
				'getVideosContainAnyCategoryVideosCategoryIdGet',
				'categoryId',
				categoryId
			)
			const localVarPath = `/videos/{category_id}`.replace(
				`{${'category_id'}}`,
				encodeURIComponent(String(categoryId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get videos merged VimeoAPI & DynamoDB
		 * @summary Get Videos Muliprocess
		 * @param {boolean} [all]
		 * @param {number} [page]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getVideosMuliprocessVideosAsyncGet: async (
			all?: boolean,
			page?: number,
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/videos/async`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			if (all !== undefined) {
				localVarQueryParameter['all'] = all
			}

			if (page !== undefined) {
				localVarQueryParameter['page'] = page
			}

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get videos from DynamoDB
		 * @summary Get Videos
		 * @param {VideoFilter} videoFilter
		 * @param {boolean} [open]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getVideosVideosPost: async (
			videoFilter: VideoFilter,
			open?: boolean,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'videoFilter' is not null or undefined
			assertParamExists('getVideosVideosPost', 'videoFilter', videoFilter)
			const localVarPath = `/videos`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			if (open !== undefined) {
				localVarQueryParameter['open'] = open
			}

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				videoFilter,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get a specific video from VimeoAPI
		 * @summary Get Vimeo Video
		 * @param {any} videoId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getVimeoVideoVimeoVideoVideoIdGet: async (
			videoId: any,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'videoId' is not null or undefined
			assertParamExists(
				'getVimeoVideoVimeoVideoVideoIdGet',
				'videoId',
				videoId
			)
			const localVarPath = `/vimeo/video/{video_id}`.replace(
				`{${'video_id'}}`,
				encodeURIComponent(String(videoId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get videos from VimeoAPI
		 * @summary Get Vimeo Videos
		 * @param {any} [all]
		 * @param {any} [page]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getVimeoVideosVimeoVideosGet: async (
			all?: any,
			page?: any,
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/vimeo/videos`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			if (all !== undefined) {
				localVarQueryParameter['all'] = all
			}

			if (page !== undefined) {
				localVarQueryParameter['page'] = page
			}

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Post banner to DynamoDB
		 * @summary Post Banner
		 * @param {ReqBannerPost} reqBannerPost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postBannerBannerPost: async (
			reqBannerPost: ReqBannerPost,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqBannerPost' is not null or undefined
			assertParamExists(
				'postBannerBannerPost',
				'reqBannerPost',
				reqBannerPost
			)
			const localVarPath = `/banner`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqBannerPost,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Upload banner image to S3 bucket
		 * @summary Post Banner Image
		 * @param {any} image
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postBannerImageBannerImagePost: async (
			image: any,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'image' is not null or undefined
			assertParamExists('postBannerImageBannerImagePost', 'image', image)
			const localVarPath = `/banner/image`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any
			const localVarFormParams = new ((configuration &&
				configuration.formDataCtor) ||
				FormData)()

			if (image !== undefined) {
				localVarFormParams.append('image', image as any)
			}

			localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = localVarFormParams

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Post category to DynamoDB
		 * @summary Post Category
		 * @param {ReqCategoryPost} reqCategoryPost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postCategoryCategoryPost: async (
			reqCategoryPost: ReqCategoryPost,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqCategoryPost' is not null or undefined
			assertParamExists(
				'postCategoryCategoryPost',
				'reqCategoryPost',
				reqCategoryPost
			)
			const localVarPath = `/category`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqCategoryPost,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Post favorite video to DynamoDB
		 * @summary Post Favorite
		 * @param {ReqFavorite} reqFavorite
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postFavoriteFavoritePost: async (
			reqFavorite: ReqFavorite,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqFavorite' is not null or undefined
			assertParamExists(
				'postFavoriteFavoritePost',
				'reqFavorite',
				reqFavorite
			)
			const localVarPath = `/favorite`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqFavorite,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Post history to dynamoDB
		 * @summary Post History
		 * @param {ReqHistory} reqHistory
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postHistoryHistoryPost: async (
			reqHistory: ReqHistory,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqHistory' is not null or undefined
			assertParamExists(
				'postHistoryHistoryPost',
				'reqHistory',
				reqHistory
			)
			const localVarPath = `/history`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqHistory,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Post like for video to DynamoDB
		 * @summary Post Like
		 * @param {ReqLikePost} reqLikePost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postLikeLikePost: async (
			reqLikePost: ReqLikePost,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqLikePost' is not null or undefined
			assertParamExists('postLikeLikePost', 'reqLikePost', reqLikePost)
			const localVarPath = `/like`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqLikePost,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Post learning path to DynamoDB
		 * @summary Post Path
		 * @param {ReqPathPost} reqPathPost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postPathPathPost: async (
			reqPathPost: ReqPathPost,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqPathPost' is not null or undefined
			assertParamExists('postPathPathPost', 'reqPathPost', reqPathPost)
			const localVarPath = `/path`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqPathPost,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Post tag to DynamoDB
		 * @summary Post Tag
		 * @param {ReqTagPost} reqTagPost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postTagTagPost: async (
			reqTagPost: ReqTagPost,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqTagPost' is not null or undefined
			assertParamExists('postTagTagPost', 'reqTagPost', reqTagPost)
			const localVarPath = `/tag`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqTagPost,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Post thread for video to DynamoDB
		 * @summary Post Thread
		 * @param {ReqThreadPost} reqThreadPost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postThreadThreadPost: async (
			reqThreadPost: ReqThreadPost,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqThreadPost' is not null or undefined
			assertParamExists(
				'postThreadThreadPost',
				'reqThreadPost',
				reqThreadPost
			)
			const localVarPath = `/thread`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqThreadPost,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Upload thumbnail to vimeo
		 * @summary Post Thumbnail Vimeo
		 * @param {number} videoId
		 * @param {any} image
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postThumbnailVimeoVideoThumbnailVideoIdPost: async (
			videoId: number,
			image: any,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'videoId' is not null or undefined
			assertParamExists(
				'postThumbnailVimeoVideoThumbnailVideoIdPost',
				'videoId',
				videoId
			)
			// verify required parameter 'image' is not null or undefined
			assertParamExists(
				'postThumbnailVimeoVideoThumbnailVideoIdPost',
				'image',
				image
			)
			const localVarPath = `/video/thumbnail/{video_id}`.replace(
				`{${'video_id'}}`,
				encodeURIComponent(String(videoId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any
			const localVarFormParams = new ((configuration &&
				configuration.formDataCtor) ||
				FormData)()

			if (image !== undefined) {
				localVarFormParams.append('image', image as any)
			}

			localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = localVarFormParams

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Get upload URL to vimeo
		 * @summary Post Upload File
		 * @param {ReqFile} reqFile
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postUploadFileUploadPost: async (
			reqFile: ReqFile,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqFile' is not null or undefined
			assertParamExists('postUploadFileUploadPost', 'reqFile', reqFile)
			const localVarPath = `/upload`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqFile,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Post upload status to DynamoDB
		 * @summary Post Upload Status
		 * @param {ReqUploadStatusPost} reqUploadStatusPost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postUploadStatusUploadStatusPost: async (
			reqUploadStatusPost: ReqUploadStatusPost,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqUploadStatusPost' is not null or undefined
			assertParamExists(
				'postUploadStatusUploadStatusPost',
				'reqUploadStatusPost',
				reqUploadStatusPost
			)
			const localVarPath = `/upload/status`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqUploadStatusPost,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Post user to dynamoDB
		 * @summary Post User
		 * @param {ReqUser} reqUser
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postUserUserPost: async (
			reqUser: ReqUser,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqUser' is not null or undefined
			assertParamExists('postUserUserPost', 'reqUser', reqUser)
			const localVarPath = `/user`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqUser,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Post video to DynamoDB
		 * @summary Post Video To Db
		 * @param {ReqVideoPost} reqVideoPost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postVideoToDbVideoPost: async (
			reqVideoPost: ReqVideoPost,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqVideoPost' is not null or undefined
			assertParamExists(
				'postVideoToDbVideoPost',
				'reqVideoPost',
				reqVideoPost
			)
			const localVarPath = `/video`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqVideoPost,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Put banner to DynamoDB
		 * @summary Put Banner
		 * @param {ReqBannerPut} reqBannerPut
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		putBannerBannerPut: async (
			reqBannerPut: ReqBannerPut,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqBannerPut' is not null or undefined
			assertParamExists(
				'putBannerBannerPut',
				'reqBannerPut',
				reqBannerPut
			)
			const localVarPath = `/banner`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'PUT',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqBannerPut,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Put category to DynamoDB
		 * @summary Put Category
		 * @param {ReqCategoryPut} reqCategoryPut
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		putCategoryCategoryPut: async (
			reqCategoryPut: ReqCategoryPut,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqCategoryPut' is not null or undefined
			assertParamExists(
				'putCategoryCategoryPut',
				'reqCategoryPut',
				reqCategoryPut
			)
			const localVarPath = `/category`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'PUT',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqCategoryPut,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Put learning path and relations to DynamoDB
		 * @summary Put Path
		 * @param {ReqPathPutTransact} reqPathPutTransact
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		putPathPathPut: async (
			reqPathPutTransact: ReqPathPutTransact,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqPathPutTransact' is not null or undefined
			assertParamExists(
				'putPathPathPut',
				'reqPathPutTransact',
				reqPathPutTransact
			)
			const localVarPath = `/path`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'PUT',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqPathPutTransact,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Put tag to DynamoDB
		 * @summary Put Tag
		 * @param {ReqTagPut} reqTagPut
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		putTagTagPut: async (
			reqTagPut: ReqTagPut,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqTagPut' is not null or undefined
			assertParamExists('putTagTagPut', 'reqTagPut', reqTagPut)
			const localVarPath = `/tag`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'PUT',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqTagPut,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Put thread for video to DynamoDB
		 * @summary Put Thread
		 * @param {ReqThreadPut} reqThreadPut
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		putThreadThreadPut: async (
			reqThreadPut: ReqThreadPut,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqThreadPut' is not null or undefined
			assertParamExists(
				'putThreadThreadPut',
				'reqThreadPut',
				reqThreadPut
			)
			const localVarPath = `/thread`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'PUT',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqThreadPut,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Put upload status to DynamoDB
		 * @summary Put Upload Status
		 * @param {ReqUploadStatusPut} reqUploadStatusPut
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		putUploadStatusUploadStatusPut: async (
			reqUploadStatusPut: ReqUploadStatusPut,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqUploadStatusPut' is not null or undefined
			assertParamExists(
				'putUploadStatusUploadStatusPut',
				'reqUploadStatusPut',
				reqUploadStatusPut
			)
			const localVarPath = `/upload/status`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'PUT',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqUploadStatusPut,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Put user to dynamoDB
		 * @summary Put User
		 * @param {ReqUser} reqUser
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		putUserUserPut: async (
			reqUser: ReqUser,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqUser' is not null or undefined
			assertParamExists('putUserUserPut', 'reqUser', reqUser)
			const localVarPath = `/user`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'PUT',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqUser,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Put video to dynamoDB
		 * @summary Put Video
		 * @param {ReqVideoPut} reqVideoPut
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		putVideoVideoPut: async (
			reqVideoPut: ReqVideoPut,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqVideoPut' is not null or undefined
			assertParamExists('putVideoVideoPut', 'reqVideoPut', reqVideoPut)
			const localVarPath = `/video`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'PUT',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqVideoPut,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Update title to vimeo
		 * @summary Put Vimeo Video
		 * @param {ReqVimeoPut} reqVimeoPut
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		putVimeoVideoVimeoVideoPut: async (
			reqVimeoPut: ReqVimeoPut,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reqVimeoPut' is not null or undefined
			assertParamExists(
				'putVimeoVideoVimeoVideoPut',
				'reqVimeoPut',
				reqVimeoPut
			)
			const localVarPath = `/vimeo/video`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'PUT',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reqVimeoPut,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * getting startd FastAPI
		 * @summary Read Root
		 * @param {string} [userAgent]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readRootHelloGet: async (
			userAgent?: string,
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/hello`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			if (userAgent !== undefined && userAgent !== null) {
				localVarHeaderParameter['user-agent'] = String(userAgent)
			}

			setSearchParams(
				localVarUrlObj,
				localVarQueryParameter,
				options.query
			)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
	return {
		/**
		 * delete category meta
		 * @summary Delete Category
		 * @param {any} categoryId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deleteCategoryCategoryCategoryIdDelete(
			categoryId: any,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.deleteCategoryCategoryCategoryIdDelete(
					categoryId,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Delete favorite video from DynamoDB
		 * @summary Delete Favorite
		 * @param {ReqFavorite} reqFavorite
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deleteFavoriteFavoriteDelete(
			reqFavorite: ReqFavorite,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.deleteFavoriteFavoriteDelete(
					reqFavorite,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Delete like for video from DynamoDB
		 * @summary Delete Like
		 * @param {ReqLikeDelete} reqLikeDelete
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deleteLikeLikeDelete(
			reqLikeDelete: ReqLikeDelete,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.deleteLikeLikeDelete(
					reqLikeDelete,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Delete learning path and relations from DynamoDB
		 * @summary Delete Path
		 * @param {ReqPathDeleteTransact} reqPathDeleteTransact
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deletePathPathDelete(
			reqPathDeleteTransact: ReqPathDeleteTransact,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.deletePathPathDelete(
					reqPathDeleteTransact,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * delete tag meta and video/tag relations
		 * @summary Delete Tag
		 * @param {ReqTagDelete} reqTagDelete
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deleteTagTagDelete(
			reqTagDelete: ReqTagDelete,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.deleteTagTagDelete(
					reqTagDelete,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Delete thread for video from DynamoDB
		 * @summary Delete Thread
		 * @param {ReqThreadDelete} reqThreadDelete
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deleteThreadThreadDelete(
			reqThreadDelete: ReqThreadDelete,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.deleteThreadThreadDelete(
					reqThreadDelete,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get videos from vimeo by multi process
		 * @summary Get Async Vimeo Videos Multi Process
		 * @param {boolean} [all]
		 * @param {number} [page]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getAsyncVimeoVideosMultiProcessVimeoVideosAsyncGet(
			all?: boolean,
			page?: number,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<VideoVimeo>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getAsyncVimeoVideosMultiProcessVimeoVideosAsyncGet(
					all,
					page,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get banners from DynamoDB
		 * @summary Get Banners
		 * @param {boolean} [active]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getBannersBannersGet(
			active?: boolean,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<Banner>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getBannersBannersGet(
					active,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get categories from dynamoDB
		 * @summary Get Categories
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getCategoriesCategoriesGet(
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<Category>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getCategoriesCategoriesGet(
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get videos from DynamoDB
		 * @summary Get Db Videos
		 * @param {boolean} [all]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getDbVideosDbVideosGet(
			all?: boolean,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<VideoDB>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getDbVideosDbVideosGet(
					all,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get videos from DynamoDB
		 * @summary Get Db Videos Filtered
		 * @param {VideoFilter} videoFilter
		 * @param {boolean} [all]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getDbVideosFilteredDbVideosPost(
			videoFilter: VideoFilter,
			all?: boolean,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<VideoDB>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getDbVideosFilteredDbVideosPost(
					videoFilter,
					all,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get favorite videos for each user from DynamoDB
		 * @summary Get Favorite
		 * @param {any} userId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getFavoriteFavoriteUserIdGet(
			userId: any,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<Favorite>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getFavoriteFavoriteUserIdGet(
					userId,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get histories today
		 * @summary Get Histories
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getHistoriesHistoriesGet(
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getHistoriesHistoriesGet(
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get histories for each user from DynamoDB
		 * @summary Get History
		 * @param {any} userId
		 * @param {number} [limit]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getHistoryHistoryUserIdGet(
			userId: any,
			limit?: number,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<UserHistory>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getHistoryHistoryUserIdGet(
					userId,
					limit,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get like for video from DynamoDB
		 * @summary Get Likes
		 * @param {any} videoId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getLikesLikeVideoIdGet(
			videoId: any,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Likes>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getLikesLikeVideoIdGet(
					videoId,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get learning path from DynamoDB
		 * @summary Get Path
		 * @param {any} pathId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getPathPathPathIdGet(
			pathId: any,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Path>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getPathPathPathIdGet(
					pathId,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 *
		 * @summary Get Paths Db
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getPathsDbPathsPathsGet(
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getPathsDbPathsPathsGet(options)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get learning paths and video orders from DynamoDB
		 * @summary Get Paths
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getPathsPathsGet(
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<Path>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getPathsPathsGet(options)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get videos & playback orders included in learning paths
		 * @summary Get Paths Videos
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getPathsVideosPathsVideosGet(
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getPathsVideosPathsVideosGet(
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get videos merged VimeoAPI & DynamoDB for table
		 * @summary Get Table Videos
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getTableVideosTableVideosGet(
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<VideoTableRow>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getTableVideosTableVideosGet(
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get tags from dynamoDB
		 * @summary Get Tags
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getTagsTagsGet(
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<Tag>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getTagsTagsGet(options)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get threads for video from DynamoDB
		 * @summary Get Thread
		 * @param {any} videoId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getThreadThreadVideoIdGet(
			videoId: any,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<Thread>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getThreadThreadVideoIdGet(
					videoId,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get upload status to vimeo
		 * @summary Get Transcode Status
		 * @param {string} videoId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getTranscodeStatusVideoStatusGet(
			videoId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getTranscodeStatusVideoStatusGet(
					videoId,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get upload status from DynamoDB
		 * @summary Get Upload Status
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getUploadStatusUploadStatusGet(
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<UploadStatus>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getUploadStatusUploadStatusGet(
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get login users today
		 * @summary Get User Count
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getUserCountUsersLoginGet(
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getUserCountUsersLoginGet(
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get user from DynamoDB
		 * @summary Get User
		 * @param {any} userId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getUserUserUserIdGet(
			userId: any,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getUserUserUserIdGet(
					userId,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get users from dynamoDB
		 * @summary Get Users
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getUsersUsersGet(
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<User>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getUsersUsersGet(options)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get video from DynamoDB
		 * @summary Get Video
		 * @param {any} videoId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getVideoVideoVideoIdGet(
			videoId: any,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideoDB>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getVideoVideoVideoIdGet(
					videoId,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * get videos contain any tag
		 * @summary Get Videos Contain Any Category
		 * @param {any} categoryId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getVideosContainAnyCategoryVideosCategoryIdGet(
			categoryId: any,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getVideosContainAnyCategoryVideosCategoryIdGet(
					categoryId,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get videos merged VimeoAPI & DynamoDB
		 * @summary Get Videos Muliprocess
		 * @param {boolean} [all]
		 * @param {number} [page]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getVideosMuliprocessVideosAsyncGet(
			all?: boolean,
			page?: number,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<Video>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getVideosMuliprocessVideosAsyncGet(
					all,
					page,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get videos from DynamoDB
		 * @summary Get Videos
		 * @param {VideoFilter} videoFilter
		 * @param {boolean} [open]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getVideosVideosPost(
			videoFilter: VideoFilter,
			open?: boolean,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<VideoDB>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getVideosVideosPost(
					videoFilter,
					open,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get a specific video from VimeoAPI
		 * @summary Get Vimeo Video
		 * @param {any} videoId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getVimeoVideoVimeoVideoVideoIdGet(
			videoId: any,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<VideoVimeo>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getVimeoVideoVimeoVideoVideoIdGet(
					videoId,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get videos from VimeoAPI
		 * @summary Get Vimeo Videos
		 * @param {any} [all]
		 * @param {any} [page]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getVimeoVideosVimeoVideosGet(
			all?: any,
			page?: any,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<VideoVimeo>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getVimeoVideosVimeoVideosGet(
					all,
					page,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Post banner to DynamoDB
		 * @summary Post Banner
		 * @param {ReqBannerPost} reqBannerPost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postBannerBannerPost(
			reqBannerPost: ReqBannerPost,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.postBannerBannerPost(
					reqBannerPost,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Upload banner image to S3 bucket
		 * @summary Post Banner Image
		 * @param {any} image
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postBannerImageBannerImagePost(
			image: any,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<BannerImage>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.postBannerImageBannerImagePost(
					image,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Post category to DynamoDB
		 * @summary Post Category
		 * @param {ReqCategoryPost} reqCategoryPost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postCategoryCategoryPost(
			reqCategoryPost: ReqCategoryPost,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.postCategoryCategoryPost(
					reqCategoryPost,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Post favorite video to DynamoDB
		 * @summary Post Favorite
		 * @param {ReqFavorite} reqFavorite
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postFavoriteFavoritePost(
			reqFavorite: ReqFavorite,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.postFavoriteFavoritePost(
					reqFavorite,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Post history to dynamoDB
		 * @summary Post History
		 * @param {ReqHistory} reqHistory
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postHistoryHistoryPost(
			reqHistory: ReqHistory,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.postHistoryHistoryPost(
					reqHistory,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Post like for video to DynamoDB
		 * @summary Post Like
		 * @param {ReqLikePost} reqLikePost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postLikeLikePost(
			reqLikePost: ReqLikePost,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.postLikeLikePost(
					reqLikePost,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Post learning path to DynamoDB
		 * @summary Post Path
		 * @param {ReqPathPost} reqPathPost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postPathPathPost(
			reqPathPost: ReqPathPost,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.postPathPathPost(
					reqPathPost,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Post tag to DynamoDB
		 * @summary Post Tag
		 * @param {ReqTagPost} reqTagPost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postTagTagPost(
			reqTagPost: ReqTagPost,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.postTagTagPost(
					reqTagPost,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Post thread for video to DynamoDB
		 * @summary Post Thread
		 * @param {ReqThreadPost} reqThreadPost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postThreadThreadPost(
			reqThreadPost: ReqThreadPost,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.postThreadThreadPost(
					reqThreadPost,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Upload thumbnail to vimeo
		 * @summary Post Thumbnail Vimeo
		 * @param {number} videoId
		 * @param {any} image
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postThumbnailVimeoVideoThumbnailVideoIdPost(
			videoId: number,
			image: any,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.postThumbnailVimeoVideoThumbnailVideoIdPost(
					videoId,
					image,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Get upload URL to vimeo
		 * @summary Post Upload File
		 * @param {ReqFile} reqFile
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postUploadFileUploadPost(
			reqFile: ReqFile,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<UploadFile>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.postUploadFileUploadPost(
					reqFile,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Post upload status to DynamoDB
		 * @summary Post Upload Status
		 * @param {ReqUploadStatusPost} reqUploadStatusPost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postUploadStatusUploadStatusPost(
			reqUploadStatusPost: ReqUploadStatusPost,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ResUploadStatus>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.postUploadStatusUploadStatusPost(
					reqUploadStatusPost,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Post user to dynamoDB
		 * @summary Post User
		 * @param {ReqUser} reqUser
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postUserUserPost(
			reqUser: ReqUser,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.postUserUserPost(
					reqUser,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Post video to DynamoDB
		 * @summary Post Video To Db
		 * @param {ReqVideoPost} reqVideoPost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postVideoToDbVideoPost(
			reqVideoPost: ReqVideoPost,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.postVideoToDbVideoPost(
					reqVideoPost,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Put banner to DynamoDB
		 * @summary Put Banner
		 * @param {ReqBannerPut} reqBannerPut
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async putBannerBannerPut(
			reqBannerPut: ReqBannerPut,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.putBannerBannerPut(
					reqBannerPut,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Put category to DynamoDB
		 * @summary Put Category
		 * @param {ReqCategoryPut} reqCategoryPut
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async putCategoryCategoryPut(
			reqCategoryPut: ReqCategoryPut,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.putCategoryCategoryPut(
					reqCategoryPut,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Put learning path and relations to DynamoDB
		 * @summary Put Path
		 * @param {ReqPathPutTransact} reqPathPutTransact
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async putPathPathPut(
			reqPathPutTransact: ReqPathPutTransact,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.putPathPathPut(
					reqPathPutTransact,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Put tag to DynamoDB
		 * @summary Put Tag
		 * @param {ReqTagPut} reqTagPut
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async putTagTagPut(
			reqTagPut: ReqTagPut,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.putTagTagPut(reqTagPut, options)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Put thread for video to DynamoDB
		 * @summary Put Thread
		 * @param {ReqThreadPut} reqThreadPut
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async putThreadThreadPut(
			reqThreadPut: ReqThreadPut,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.putThreadThreadPut(
					reqThreadPut,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Put upload status to DynamoDB
		 * @summary Put Upload Status
		 * @param {ReqUploadStatusPut} reqUploadStatusPut
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async putUploadStatusUploadStatusPut(
			reqUploadStatusPut: ReqUploadStatusPut,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ResUploadStatus>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.putUploadStatusUploadStatusPut(
					reqUploadStatusPut,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Put user to dynamoDB
		 * @summary Put User
		 * @param {ReqUser} reqUser
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async putUserUserPut(
			reqUser: ReqUser,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.putUserUserPut(reqUser, options)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Put video to dynamoDB
		 * @summary Put Video
		 * @param {ReqVideoPut} reqVideoPut
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async putVideoVideoPut(
			reqVideoPut: ReqVideoPut,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.putVideoVideoPut(
					reqVideoPut,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * Update title to vimeo
		 * @summary Put Vimeo Video
		 * @param {ReqVimeoPut} reqVimeoPut
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async putVimeoVideoVimeoVideoPut(
			reqVimeoPut: ReqVimeoPut,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.putVimeoVideoVimeoVideoPut(
					reqVimeoPut,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 * getting startd FastAPI
		 * @summary Read Root
		 * @param {string} [userAgent]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async readRootHelloGet(
			userAgent?: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.readRootHelloGet(
					userAgent,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
	}
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = DefaultApiFp(configuration)
	return {
		/**
		 * delete category meta
		 * @summary Delete Category
		 * @param {any} categoryId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteCategoryCategoryCategoryIdDelete(
			categoryId: any,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.deleteCategoryCategoryCategoryIdDelete(categoryId, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Delete favorite video from DynamoDB
		 * @summary Delete Favorite
		 * @param {ReqFavorite} reqFavorite
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteFavoriteFavoriteDelete(
			reqFavorite: ReqFavorite,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.deleteFavoriteFavoriteDelete(reqFavorite, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Delete like for video from DynamoDB
		 * @summary Delete Like
		 * @param {ReqLikeDelete} reqLikeDelete
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteLikeLikeDelete(
			reqLikeDelete: ReqLikeDelete,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.deleteLikeLikeDelete(reqLikeDelete, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Delete learning path and relations from DynamoDB
		 * @summary Delete Path
		 * @param {ReqPathDeleteTransact} reqPathDeleteTransact
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deletePathPathDelete(
			reqPathDeleteTransact: ReqPathDeleteTransact,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.deletePathPathDelete(reqPathDeleteTransact, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * delete tag meta and video/tag relations
		 * @summary Delete Tag
		 * @param {ReqTagDelete} reqTagDelete
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteTagTagDelete(
			reqTagDelete: ReqTagDelete,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.deleteTagTagDelete(reqTagDelete, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Delete thread for video from DynamoDB
		 * @summary Delete Thread
		 * @param {ReqThreadDelete} reqThreadDelete
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteThreadThreadDelete(
			reqThreadDelete: ReqThreadDelete,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.deleteThreadThreadDelete(reqThreadDelete, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get videos from vimeo by multi process
		 * @summary Get Async Vimeo Videos Multi Process
		 * @param {boolean} [all]
		 * @param {number} [page]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getAsyncVimeoVideosMultiProcessVimeoVideosAsyncGet(
			all?: boolean,
			page?: number,
			options?: any
		): AxiosPromise<VideoVimeo> {
			return localVarFp
				.getAsyncVimeoVideosMultiProcessVimeoVideosAsyncGet(
					all,
					page,
					options
				)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get banners from DynamoDB
		 * @summary Get Banners
		 * @param {boolean} [active]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getBannersBannersGet(
			active?: boolean,
			options?: any
		): AxiosPromise<Array<Banner>> {
			return localVarFp
				.getBannersBannersGet(active, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get categories from dynamoDB
		 * @summary Get Categories
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getCategoriesCategoriesGet(
			options?: any
		): AxiosPromise<Array<Category>> {
			return localVarFp
				.getCategoriesCategoriesGet(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get videos from DynamoDB
		 * @summary Get Db Videos
		 * @param {boolean} [all]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getDbVideosDbVideosGet(
			all?: boolean,
			options?: any
		): AxiosPromise<Array<VideoDB>> {
			return localVarFp
				.getDbVideosDbVideosGet(all, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get videos from DynamoDB
		 * @summary Get Db Videos Filtered
		 * @param {VideoFilter} videoFilter
		 * @param {boolean} [all]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getDbVideosFilteredDbVideosPost(
			videoFilter: VideoFilter,
			all?: boolean,
			options?: any
		): AxiosPromise<Array<VideoDB>> {
			return localVarFp
				.getDbVideosFilteredDbVideosPost(videoFilter, all, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get favorite videos for each user from DynamoDB
		 * @summary Get Favorite
		 * @param {any} userId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getFavoriteFavoriteUserIdGet(
			userId: any,
			options?: any
		): AxiosPromise<Array<Favorite>> {
			return localVarFp
				.getFavoriteFavoriteUserIdGet(userId, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get histories today
		 * @summary Get Histories
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getHistoriesHistoriesGet(options?: any): AxiosPromise<any> {
			return localVarFp
				.getHistoriesHistoriesGet(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get histories for each user from DynamoDB
		 * @summary Get History
		 * @param {any} userId
		 * @param {number} [limit]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getHistoryHistoryUserIdGet(
			userId: any,
			limit?: number,
			options?: any
		): AxiosPromise<Array<UserHistory>> {
			return localVarFp
				.getHistoryHistoryUserIdGet(userId, limit, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get like for video from DynamoDB
		 * @summary Get Likes
		 * @param {any} videoId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLikesLikeVideoIdGet(
			videoId: any,
			options?: any
		): AxiosPromise<Likes> {
			return localVarFp
				.getLikesLikeVideoIdGet(videoId, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get learning path from DynamoDB
		 * @summary Get Path
		 * @param {any} pathId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getPathPathPathIdGet(pathId: any, options?: any): AxiosPromise<Path> {
			return localVarFp
				.getPathPathPathIdGet(pathId, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @summary Get Paths Db
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getPathsDbPathsPathsGet(options?: any): AxiosPromise<any> {
			return localVarFp
				.getPathsDbPathsPathsGet(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get learning paths and video orders from DynamoDB
		 * @summary Get Paths
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getPathsPathsGet(options?: any): AxiosPromise<Array<Path>> {
			return localVarFp
				.getPathsPathsGet(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get videos & playback orders included in learning paths
		 * @summary Get Paths Videos
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getPathsVideosPathsVideosGet(options?: any): AxiosPromise<any> {
			return localVarFp
				.getPathsVideosPathsVideosGet(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get videos merged VimeoAPI & DynamoDB for table
		 * @summary Get Table Videos
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getTableVideosTableVideosGet(
			options?: any
		): AxiosPromise<Array<VideoTableRow>> {
			return localVarFp
				.getTableVideosTableVideosGet(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get tags from dynamoDB
		 * @summary Get Tags
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getTagsTagsGet(options?: any): AxiosPromise<Array<Tag>> {
			return localVarFp
				.getTagsTagsGet(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get threads for video from DynamoDB
		 * @summary Get Thread
		 * @param {any} videoId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getThreadThreadVideoIdGet(
			videoId: any,
			options?: any
		): AxiosPromise<Array<Thread>> {
			return localVarFp
				.getThreadThreadVideoIdGet(videoId, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get upload status to vimeo
		 * @summary Get Transcode Status
		 * @param {string} videoId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getTranscodeStatusVideoStatusGet(
			videoId: string,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.getTranscodeStatusVideoStatusGet(videoId, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get upload status from DynamoDB
		 * @summary Get Upload Status
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getUploadStatusUploadStatusGet(
			options?: any
		): AxiosPromise<Array<UploadStatus>> {
			return localVarFp
				.getUploadStatusUploadStatusGet(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get login users today
		 * @summary Get User Count
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getUserCountUsersLoginGet(options?: any): AxiosPromise<any> {
			return localVarFp
				.getUserCountUsersLoginGet(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get user from DynamoDB
		 * @summary Get User
		 * @param {any} userId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getUserUserUserIdGet(userId: any, options?: any): AxiosPromise<any> {
			return localVarFp
				.getUserUserUserIdGet(userId, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get users from dynamoDB
		 * @summary Get Users
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getUsersUsersGet(options?: any): AxiosPromise<Array<User>> {
			return localVarFp
				.getUsersUsersGet(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get video from DynamoDB
		 * @summary Get Video
		 * @param {any} videoId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getVideoVideoVideoIdGet(
			videoId: any,
			options?: any
		): AxiosPromise<VideoDB> {
			return localVarFp
				.getVideoVideoVideoIdGet(videoId, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * get videos contain any tag
		 * @summary Get Videos Contain Any Category
		 * @param {any} categoryId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getVideosContainAnyCategoryVideosCategoryIdGet(
			categoryId: any,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.getVideosContainAnyCategoryVideosCategoryIdGet(
					categoryId,
					options
				)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get videos merged VimeoAPI & DynamoDB
		 * @summary Get Videos Muliprocess
		 * @param {boolean} [all]
		 * @param {number} [page]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getVideosMuliprocessVideosAsyncGet(
			all?: boolean,
			page?: number,
			options?: any
		): AxiosPromise<Array<Video>> {
			return localVarFp
				.getVideosMuliprocessVideosAsyncGet(all, page, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get videos from DynamoDB
		 * @summary Get Videos
		 * @param {VideoFilter} videoFilter
		 * @param {boolean} [open]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getVideosVideosPost(
			videoFilter: VideoFilter,
			open?: boolean,
			options?: any
		): AxiosPromise<Array<VideoDB>> {
			return localVarFp
				.getVideosVideosPost(videoFilter, open, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get a specific video from VimeoAPI
		 * @summary Get Vimeo Video
		 * @param {any} videoId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getVimeoVideoVimeoVideoVideoIdGet(
			videoId: any,
			options?: any
		): AxiosPromise<VideoVimeo> {
			return localVarFp
				.getVimeoVideoVimeoVideoVideoIdGet(videoId, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get videos from VimeoAPI
		 * @summary Get Vimeo Videos
		 * @param {any} [all]
		 * @param {any} [page]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getVimeoVideosVimeoVideosGet(
			all?: any,
			page?: any,
			options?: any
		): AxiosPromise<VideoVimeo> {
			return localVarFp
				.getVimeoVideosVimeoVideosGet(all, page, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Post banner to DynamoDB
		 * @summary Post Banner
		 * @param {ReqBannerPost} reqBannerPost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postBannerBannerPost(
			reqBannerPost: ReqBannerPost,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.postBannerBannerPost(reqBannerPost, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Upload banner image to S3 bucket
		 * @summary Post Banner Image
		 * @param {any} image
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postBannerImageBannerImagePost(
			image: any,
			options?: any
		): AxiosPromise<BannerImage> {
			return localVarFp
				.postBannerImageBannerImagePost(image, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Post category to DynamoDB
		 * @summary Post Category
		 * @param {ReqCategoryPost} reqCategoryPost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postCategoryCategoryPost(
			reqCategoryPost: ReqCategoryPost,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.postCategoryCategoryPost(reqCategoryPost, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Post favorite video to DynamoDB
		 * @summary Post Favorite
		 * @param {ReqFavorite} reqFavorite
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postFavoriteFavoritePost(
			reqFavorite: ReqFavorite,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.postFavoriteFavoritePost(reqFavorite, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Post history to dynamoDB
		 * @summary Post History
		 * @param {ReqHistory} reqHistory
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postHistoryHistoryPost(
			reqHistory: ReqHistory,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.postHistoryHistoryPost(reqHistory, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Post like for video to DynamoDB
		 * @summary Post Like
		 * @param {ReqLikePost} reqLikePost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postLikeLikePost(
			reqLikePost: ReqLikePost,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.postLikeLikePost(reqLikePost, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Post learning path to DynamoDB
		 * @summary Post Path
		 * @param {ReqPathPost} reqPathPost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postPathPathPost(
			reqPathPost: ReqPathPost,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.postPathPathPost(reqPathPost, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Post tag to DynamoDB
		 * @summary Post Tag
		 * @param {ReqTagPost} reqTagPost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postTagTagPost(
			reqTagPost: ReqTagPost,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.postTagTagPost(reqTagPost, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Post thread for video to DynamoDB
		 * @summary Post Thread
		 * @param {ReqThreadPost} reqThreadPost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postThreadThreadPost(
			reqThreadPost: ReqThreadPost,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.postThreadThreadPost(reqThreadPost, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Upload thumbnail to vimeo
		 * @summary Post Thumbnail Vimeo
		 * @param {number} videoId
		 * @param {any} image
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postThumbnailVimeoVideoThumbnailVideoIdPost(
			videoId: number,
			image: any,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.postThumbnailVimeoVideoThumbnailVideoIdPost(
					videoId,
					image,
					options
				)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Get upload URL to vimeo
		 * @summary Post Upload File
		 * @param {ReqFile} reqFile
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postUploadFileUploadPost(
			reqFile: ReqFile,
			options?: any
		): AxiosPromise<UploadFile> {
			return localVarFp
				.postUploadFileUploadPost(reqFile, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Post upload status to DynamoDB
		 * @summary Post Upload Status
		 * @param {ReqUploadStatusPost} reqUploadStatusPost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postUploadStatusUploadStatusPost(
			reqUploadStatusPost: ReqUploadStatusPost,
			options?: any
		): AxiosPromise<ResUploadStatus> {
			return localVarFp
				.postUploadStatusUploadStatusPost(reqUploadStatusPost, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Post user to dynamoDB
		 * @summary Post User
		 * @param {ReqUser} reqUser
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postUserUserPost(reqUser: ReqUser, options?: any): AxiosPromise<any> {
			return localVarFp
				.postUserUserPost(reqUser, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Post video to DynamoDB
		 * @summary Post Video To Db
		 * @param {ReqVideoPost} reqVideoPost
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postVideoToDbVideoPost(
			reqVideoPost: ReqVideoPost,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.postVideoToDbVideoPost(reqVideoPost, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Put banner to DynamoDB
		 * @summary Put Banner
		 * @param {ReqBannerPut} reqBannerPut
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		putBannerBannerPut(
			reqBannerPut: ReqBannerPut,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.putBannerBannerPut(reqBannerPut, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Put category to DynamoDB
		 * @summary Put Category
		 * @param {ReqCategoryPut} reqCategoryPut
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		putCategoryCategoryPut(
			reqCategoryPut: ReqCategoryPut,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.putCategoryCategoryPut(reqCategoryPut, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Put learning path and relations to DynamoDB
		 * @summary Put Path
		 * @param {ReqPathPutTransact} reqPathPutTransact
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		putPathPathPut(
			reqPathPutTransact: ReqPathPutTransact,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.putPathPathPut(reqPathPutTransact, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Put tag to DynamoDB
		 * @summary Put Tag
		 * @param {ReqTagPut} reqTagPut
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		putTagTagPut(reqTagPut: ReqTagPut, options?: any): AxiosPromise<any> {
			return localVarFp
				.putTagTagPut(reqTagPut, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Put thread for video to DynamoDB
		 * @summary Put Thread
		 * @param {ReqThreadPut} reqThreadPut
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		putThreadThreadPut(
			reqThreadPut: ReqThreadPut,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.putThreadThreadPut(reqThreadPut, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Put upload status to DynamoDB
		 * @summary Put Upload Status
		 * @param {ReqUploadStatusPut} reqUploadStatusPut
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		putUploadStatusUploadStatusPut(
			reqUploadStatusPut: ReqUploadStatusPut,
			options?: any
		): AxiosPromise<ResUploadStatus> {
			return localVarFp
				.putUploadStatusUploadStatusPut(reqUploadStatusPut, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Put user to dynamoDB
		 * @summary Put User
		 * @param {ReqUser} reqUser
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		putUserUserPut(reqUser: ReqUser, options?: any): AxiosPromise<any> {
			return localVarFp
				.putUserUserPut(reqUser, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Put video to dynamoDB
		 * @summary Put Video
		 * @param {ReqVideoPut} reqVideoPut
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		putVideoVideoPut(
			reqVideoPut: ReqVideoPut,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.putVideoVideoPut(reqVideoPut, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Update title to vimeo
		 * @summary Put Vimeo Video
		 * @param {ReqVimeoPut} reqVimeoPut
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		putVimeoVideoVimeoVideoPut(
			reqVimeoPut: ReqVimeoPut,
			options?: any
		): AxiosPromise<any> {
			return localVarFp
				.putVimeoVideoVimeoVideoPut(reqVimeoPut, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * getting startd FastAPI
		 * @summary Read Root
		 * @param {string} [userAgent]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readRootHelloGet(userAgent?: string, options?: any): AxiosPromise<any> {
			return localVarFp
				.readRootHelloGet(userAgent, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
	/**
	 * delete category meta
	 * @summary Delete Category
	 * @param {any} categoryId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public deleteCategoryCategoryCategoryIdDelete(
		categoryId: any,
		options?: any
	) {
		return DefaultApiFp(this.configuration)
			.deleteCategoryCategoryCategoryIdDelete(categoryId, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Delete favorite video from DynamoDB
	 * @summary Delete Favorite
	 * @param {ReqFavorite} reqFavorite
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public deleteFavoriteFavoriteDelete(
		reqFavorite: ReqFavorite,
		options?: any
	) {
		return DefaultApiFp(this.configuration)
			.deleteFavoriteFavoriteDelete(reqFavorite, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Delete like for video from DynamoDB
	 * @summary Delete Like
	 * @param {ReqLikeDelete} reqLikeDelete
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public deleteLikeLikeDelete(reqLikeDelete: ReqLikeDelete, options?: any) {
		return DefaultApiFp(this.configuration)
			.deleteLikeLikeDelete(reqLikeDelete, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Delete learning path and relations from DynamoDB
	 * @summary Delete Path
	 * @param {ReqPathDeleteTransact} reqPathDeleteTransact
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public deletePathPathDelete(
		reqPathDeleteTransact: ReqPathDeleteTransact,
		options?: any
	) {
		return DefaultApiFp(this.configuration)
			.deletePathPathDelete(reqPathDeleteTransact, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * delete tag meta and video/tag relations
	 * @summary Delete Tag
	 * @param {ReqTagDelete} reqTagDelete
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public deleteTagTagDelete(reqTagDelete: ReqTagDelete, options?: any) {
		return DefaultApiFp(this.configuration)
			.deleteTagTagDelete(reqTagDelete, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Delete thread for video from DynamoDB
	 * @summary Delete Thread
	 * @param {ReqThreadDelete} reqThreadDelete
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public deleteThreadThreadDelete(
		reqThreadDelete: ReqThreadDelete,
		options?: any
	) {
		return DefaultApiFp(this.configuration)
			.deleteThreadThreadDelete(reqThreadDelete, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get videos from vimeo by multi process
	 * @summary Get Async Vimeo Videos Multi Process
	 * @param {boolean} [all]
	 * @param {number} [page]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getAsyncVimeoVideosMultiProcessVimeoVideosAsyncGet(
		all?: boolean,
		page?: number,
		options?: any
	) {
		return DefaultApiFp(this.configuration)
			.getAsyncVimeoVideosMultiProcessVimeoVideosAsyncGet(
				all,
				page,
				options
			)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get banners from DynamoDB
	 * @summary Get Banners
	 * @param {boolean} [active]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getBannersBannersGet(active?: boolean, options?: any) {
		return DefaultApiFp(this.configuration)
			.getBannersBannersGet(active, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get categories from dynamoDB
	 * @summary Get Categories
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getCategoriesCategoriesGet(options?: any) {
		return DefaultApiFp(this.configuration)
			.getCategoriesCategoriesGet(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get videos from DynamoDB
	 * @summary Get Db Videos
	 * @param {boolean} [all]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getDbVideosDbVideosGet(all?: boolean, options?: any) {
		return DefaultApiFp(this.configuration)
			.getDbVideosDbVideosGet(all, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get videos from DynamoDB
	 * @summary Get Db Videos Filtered
	 * @param {VideoFilter} videoFilter
	 * @param {boolean} [all]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getDbVideosFilteredDbVideosPost(
		videoFilter: VideoFilter,
		all?: boolean,
		options?: any
	) {
		return DefaultApiFp(this.configuration)
			.getDbVideosFilteredDbVideosPost(videoFilter, all, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get favorite videos for each user from DynamoDB
	 * @summary Get Favorite
	 * @param {any} userId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getFavoriteFavoriteUserIdGet(userId: any, options?: any) {
		return DefaultApiFp(this.configuration)
			.getFavoriteFavoriteUserIdGet(userId, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get histories today
	 * @summary Get Histories
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getHistoriesHistoriesGet(options?: any) {
		return DefaultApiFp(this.configuration)
			.getHistoriesHistoriesGet(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get histories for each user from DynamoDB
	 * @summary Get History
	 * @param {any} userId
	 * @param {number} [limit]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getHistoryHistoryUserIdGet(
		userId: any,
		limit?: number,
		options?: any
	) {
		return DefaultApiFp(this.configuration)
			.getHistoryHistoryUserIdGet(userId, limit, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get like for video from DynamoDB
	 * @summary Get Likes
	 * @param {any} videoId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getLikesLikeVideoIdGet(videoId: any, options?: any) {
		return DefaultApiFp(this.configuration)
			.getLikesLikeVideoIdGet(videoId, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get learning path from DynamoDB
	 * @summary Get Path
	 * @param {any} pathId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getPathPathPathIdGet(pathId: any, options?: any) {
		return DefaultApiFp(this.configuration)
			.getPathPathPathIdGet(pathId, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @summary Get Paths Db
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getPathsDbPathsPathsGet(options?: any) {
		return DefaultApiFp(this.configuration)
			.getPathsDbPathsPathsGet(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get learning paths and video orders from DynamoDB
	 * @summary Get Paths
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getPathsPathsGet(options?: any) {
		return DefaultApiFp(this.configuration)
			.getPathsPathsGet(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get videos & playback orders included in learning paths
	 * @summary Get Paths Videos
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getPathsVideosPathsVideosGet(options?: any) {
		return DefaultApiFp(this.configuration)
			.getPathsVideosPathsVideosGet(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get videos merged VimeoAPI & DynamoDB for table
	 * @summary Get Table Videos
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getTableVideosTableVideosGet(options?: any) {
		return DefaultApiFp(this.configuration)
			.getTableVideosTableVideosGet(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get tags from dynamoDB
	 * @summary Get Tags
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getTagsTagsGet(options?: any) {
		return DefaultApiFp(this.configuration)
			.getTagsTagsGet(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get threads for video from DynamoDB
	 * @summary Get Thread
	 * @param {any} videoId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getThreadThreadVideoIdGet(videoId: any, options?: any) {
		return DefaultApiFp(this.configuration)
			.getThreadThreadVideoIdGet(videoId, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get upload status to vimeo
	 * @summary Get Transcode Status
	 * @param {string} videoId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getTranscodeStatusVideoStatusGet(videoId: string, options?: any) {
		return DefaultApiFp(this.configuration)
			.getTranscodeStatusVideoStatusGet(videoId, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get upload status from DynamoDB
	 * @summary Get Upload Status
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getUploadStatusUploadStatusGet(options?: any) {
		return DefaultApiFp(this.configuration)
			.getUploadStatusUploadStatusGet(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get login users today
	 * @summary Get User Count
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getUserCountUsersLoginGet(options?: any) {
		return DefaultApiFp(this.configuration)
			.getUserCountUsersLoginGet(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get user from DynamoDB
	 * @summary Get User
	 * @param {any} userId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getUserUserUserIdGet(userId: any, options?: any) {
		return DefaultApiFp(this.configuration)
			.getUserUserUserIdGet(userId, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get users from dynamoDB
	 * @summary Get Users
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getUsersUsersGet(options?: any) {
		return DefaultApiFp(this.configuration)
			.getUsersUsersGet(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get video from DynamoDB
	 * @summary Get Video
	 * @param {any} videoId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getVideoVideoVideoIdGet(videoId: any, options?: any) {
		return DefaultApiFp(this.configuration)
			.getVideoVideoVideoIdGet(videoId, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * get videos contain any tag
	 * @summary Get Videos Contain Any Category
	 * @param {any} categoryId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getVideosContainAnyCategoryVideosCategoryIdGet(
		categoryId: any,
		options?: any
	) {
		return DefaultApiFp(this.configuration)
			.getVideosContainAnyCategoryVideosCategoryIdGet(categoryId, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get videos merged VimeoAPI & DynamoDB
	 * @summary Get Videos Muliprocess
	 * @param {boolean} [all]
	 * @param {number} [page]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getVideosMuliprocessVideosAsyncGet(
		all?: boolean,
		page?: number,
		options?: any
	) {
		return DefaultApiFp(this.configuration)
			.getVideosMuliprocessVideosAsyncGet(all, page, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get videos from DynamoDB
	 * @summary Get Videos
	 * @param {VideoFilter} videoFilter
	 * @param {boolean} [open]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getVideosVideosPost(
		videoFilter: VideoFilter,
		open?: boolean,
		options?: any
	) {
		return DefaultApiFp(this.configuration)
			.getVideosVideosPost(videoFilter, open, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get a specific video from VimeoAPI
	 * @summary Get Vimeo Video
	 * @param {any} videoId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getVimeoVideoVimeoVideoVideoIdGet(videoId: any, options?: any) {
		return DefaultApiFp(this.configuration)
			.getVimeoVideoVimeoVideoVideoIdGet(videoId, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get videos from VimeoAPI
	 * @summary Get Vimeo Videos
	 * @param {any} [all]
	 * @param {any} [page]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getVimeoVideosVimeoVideosGet(all?: any, page?: any, options?: any) {
		return DefaultApiFp(this.configuration)
			.getVimeoVideosVimeoVideosGet(all, page, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Post banner to DynamoDB
	 * @summary Post Banner
	 * @param {ReqBannerPost} reqBannerPost
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public postBannerBannerPost(reqBannerPost: ReqBannerPost, options?: any) {
		return DefaultApiFp(this.configuration)
			.postBannerBannerPost(reqBannerPost, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Upload banner image to S3 bucket
	 * @summary Post Banner Image
	 * @param {any} image
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public postBannerImageBannerImagePost(image: any, options?: any) {
		return DefaultApiFp(this.configuration)
			.postBannerImageBannerImagePost(image, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Post category to DynamoDB
	 * @summary Post Category
	 * @param {ReqCategoryPost} reqCategoryPost
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public postCategoryCategoryPost(
		reqCategoryPost: ReqCategoryPost,
		options?: any
	) {
		return DefaultApiFp(this.configuration)
			.postCategoryCategoryPost(reqCategoryPost, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Post favorite video to DynamoDB
	 * @summary Post Favorite
	 * @param {ReqFavorite} reqFavorite
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public postFavoriteFavoritePost(reqFavorite: ReqFavorite, options?: any) {
		return DefaultApiFp(this.configuration)
			.postFavoriteFavoritePost(reqFavorite, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Post history to dynamoDB
	 * @summary Post History
	 * @param {ReqHistory} reqHistory
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public postHistoryHistoryPost(reqHistory: ReqHistory, options?: any) {
		return DefaultApiFp(this.configuration)
			.postHistoryHistoryPost(reqHistory, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Post like for video to DynamoDB
	 * @summary Post Like
	 * @param {ReqLikePost} reqLikePost
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public postLikeLikePost(reqLikePost: ReqLikePost, options?: any) {
		return DefaultApiFp(this.configuration)
			.postLikeLikePost(reqLikePost, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Post learning path to DynamoDB
	 * @summary Post Path
	 * @param {ReqPathPost} reqPathPost
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public postPathPathPost(reqPathPost: ReqPathPost, options?: any) {
		return DefaultApiFp(this.configuration)
			.postPathPathPost(reqPathPost, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Post tag to DynamoDB
	 * @summary Post Tag
	 * @param {ReqTagPost} reqTagPost
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public postTagTagPost(reqTagPost: ReqTagPost, options?: any) {
		return DefaultApiFp(this.configuration)
			.postTagTagPost(reqTagPost, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Post thread for video to DynamoDB
	 * @summary Post Thread
	 * @param {ReqThreadPost} reqThreadPost
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public postThreadThreadPost(reqThreadPost: ReqThreadPost, options?: any) {
		return DefaultApiFp(this.configuration)
			.postThreadThreadPost(reqThreadPost, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Upload thumbnail to vimeo
	 * @summary Post Thumbnail Vimeo
	 * @param {number} videoId
	 * @param {any} image
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public postThumbnailVimeoVideoThumbnailVideoIdPost(
		videoId: number,
		image: any,
		options?: any
	) {
		return DefaultApiFp(this.configuration)
			.postThumbnailVimeoVideoThumbnailVideoIdPost(
				videoId,
				image,
				options
			)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Get upload URL to vimeo
	 * @summary Post Upload File
	 * @param {ReqFile} reqFile
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public postUploadFileUploadPost(reqFile: ReqFile, options?: any) {
		return DefaultApiFp(this.configuration)
			.postUploadFileUploadPost(reqFile, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Post upload status to DynamoDB
	 * @summary Post Upload Status
	 * @param {ReqUploadStatusPost} reqUploadStatusPost
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public postUploadStatusUploadStatusPost(
		reqUploadStatusPost: ReqUploadStatusPost,
		options?: any
	) {
		return DefaultApiFp(this.configuration)
			.postUploadStatusUploadStatusPost(reqUploadStatusPost, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Post user to dynamoDB
	 * @summary Post User
	 * @param {ReqUser} reqUser
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public postUserUserPost(reqUser: ReqUser, options?: any) {
		return DefaultApiFp(this.configuration)
			.postUserUserPost(reqUser, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Post video to DynamoDB
	 * @summary Post Video To Db
	 * @param {ReqVideoPost} reqVideoPost
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public postVideoToDbVideoPost(reqVideoPost: ReqVideoPost, options?: any) {
		return DefaultApiFp(this.configuration)
			.postVideoToDbVideoPost(reqVideoPost, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Put banner to DynamoDB
	 * @summary Put Banner
	 * @param {ReqBannerPut} reqBannerPut
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public putBannerBannerPut(reqBannerPut: ReqBannerPut, options?: any) {
		return DefaultApiFp(this.configuration)
			.putBannerBannerPut(reqBannerPut, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Put category to DynamoDB
	 * @summary Put Category
	 * @param {ReqCategoryPut} reqCategoryPut
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public putCategoryCategoryPut(
		reqCategoryPut: ReqCategoryPut,
		options?: any
	) {
		return DefaultApiFp(this.configuration)
			.putCategoryCategoryPut(reqCategoryPut, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Put learning path and relations to DynamoDB
	 * @summary Put Path
	 * @param {ReqPathPutTransact} reqPathPutTransact
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public putPathPathPut(
		reqPathPutTransact: ReqPathPutTransact,
		options?: any
	) {
		return DefaultApiFp(this.configuration)
			.putPathPathPut(reqPathPutTransact, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Put tag to DynamoDB
	 * @summary Put Tag
	 * @param {ReqTagPut} reqTagPut
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public putTagTagPut(reqTagPut: ReqTagPut, options?: any) {
		return DefaultApiFp(this.configuration)
			.putTagTagPut(reqTagPut, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Put thread for video to DynamoDB
	 * @summary Put Thread
	 * @param {ReqThreadPut} reqThreadPut
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public putThreadThreadPut(reqThreadPut: ReqThreadPut, options?: any) {
		return DefaultApiFp(this.configuration)
			.putThreadThreadPut(reqThreadPut, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Put upload status to DynamoDB
	 * @summary Put Upload Status
	 * @param {ReqUploadStatusPut} reqUploadStatusPut
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public putUploadStatusUploadStatusPut(
		reqUploadStatusPut: ReqUploadStatusPut,
		options?: any
	) {
		return DefaultApiFp(this.configuration)
			.putUploadStatusUploadStatusPut(reqUploadStatusPut, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Put user to dynamoDB
	 * @summary Put User
	 * @param {ReqUser} reqUser
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public putUserUserPut(reqUser: ReqUser, options?: any) {
		return DefaultApiFp(this.configuration)
			.putUserUserPut(reqUser, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Put video to dynamoDB
	 * @summary Put Video
	 * @param {ReqVideoPut} reqVideoPut
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public putVideoVideoPut(reqVideoPut: ReqVideoPut, options?: any) {
		return DefaultApiFp(this.configuration)
			.putVideoVideoPut(reqVideoPut, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Update title to vimeo
	 * @summary Put Vimeo Video
	 * @param {ReqVimeoPut} reqVimeoPut
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public putVimeoVideoVimeoVideoPut(reqVimeoPut: ReqVimeoPut, options?: any) {
		return DefaultApiFp(this.configuration)
			.putVimeoVideoVimeoVideoPut(reqVimeoPut, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * getting startd FastAPI
	 * @summary Read Root
	 * @param {string} [userAgent]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public readRootHelloGet(userAgent?: string, options?: any) {
		return DefaultApiFp(this.configuration)
			.readRootHelloGet(userAgent, options)
			.then((request) => request(this.axios, this.basePath))
	}
}
